<!DOCTYPE html>
<html lang="it" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Convertitore Immagini Pro – CronoTools</title>
  <meta name="description" content="Converti immagini con un'interfaccia avanzata ispirata a iOS. Supporta drag-and-drop, temi multipli e animazioni fluide con il design CronoGlass." />
  <link rel="stylesheet" href="style.css" />
</head>
<body>

<nav>
  <div class="logo">
    <img src="https://images.pexels.com/photos/4164418/pexels-photo-4164418.jpeg?auto=compress&cs=tinysrgb&w=64&h=64&dpr=2" alt="CronoTools Logo" />
    ⚡ CronoTools
  </div>

  <div class="nav-title-scrolled">
    CronoTools
  </div>

  <ul class="desktop-nav">
    <li><a href="index.html" class="active">Converti</a></li>
    <li><a href="ridimensiona.html">Ridimensiona</a></li>
    <li><a href="ruota-immagini.html">Ruota</a></li>
    <li><a href="flip-immagini.html">Specchia</a></li>
    <li><a href="crop-immagini.html">Ritaglia</a></li>
    <li><a href="base64.html">Base64</a></li>
    <li><a href="scala-grigi.html">Filtri</a></li>
    <li><a href="weight.html">Converti Peso</a></li>
    <li><a href="share.html">Condividi</a></li>
  </ul>

  <div class="nav-controls">
    <select id="themeSelector" title="Seleziona Tema">
      <option value="dark">Scuro</option>
      <option value="light">Chiaro</option>
      <option value="midnight">Midnight</option>
      <option value="slate">Slate</option>
    </select>
  </div>

  <button id="mobile-menu-trigger" title="Apri Menu">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
      <line x1="3" y1="6" x2="21" y2="6" />
      <line x1="3" y1="12" x2="21" y2="12" />
      <line x1="3" y1="18" x2="21" y2="18" />
    </svg>
  </button>
</nav>

<div class="mobile-nav" id="mobileMenu">
  <button id="mobile-menu-close" title="Chiudi Menu">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
      <line x1="18" y1="6" x2="6" y2="18" />
      <line x1="6" y1="6" x2="18" y2="18" />
    </svg>
  </button>

  <ul>
    <li><a href="index.html" class="active">Converti</a></li>
    <li><a href="ridimensiona.html">Ridimensiona</a></li>
    <li><a href="ruota-immagini.html">Ruota</a></li>
    <li><a href="flip-immagini.html">Specchia</a></li>
    <li><a href="crop-immagini.html">Ritaglia</a></li>
    <li><a href="base64.html">Base64</a></li>
    <li><a href="scala-grigi.html">Filtri</a></li>
    <li><a href="weight.html">Converti Peso</a></li>
    <li><a href="share.html">Condividi</a></li>
  </ul>

  <div class="nav-controls">
    <select id="themeSelectorMobile" title="Seleziona Tema">
      <option value="dark">Scuro</option>
      <option value="light">Chiaro</option>
      <option value="midnight">Midnight</option>
      <option value="slate">Slate</option>
    </select>
  </div>
</div>

<div class="content-wrapper">
  <header class="main-header">
    <h1 id="mainTitle">Convertitore Immagini</h1>
  </header>

  <main>
    <p class="description">Trascina le tue immagini, scegli un formato e convertile all'istante. Un'esperienza di conversione potente, racchiusa nel design CronoGlass.</p>

    <div class="ios-card">
      <div id="dropZone">
        <svg class="upload-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
        <p><span>Trascina i file qui o</span> <span>clicca per selezionare</span></p>
      </div>
      <input type="file" id="inputFiles" accept="image/*" multiple />

      <div class="ios-list">
        <label for="outputFormat">
          <span>Formato di destinazione</span>
          <select id="outputFormat">
            <option value="jpeg">JPEG (.jpg, .jpeg)</option>
            <option value="png">PNG (.png)</option>
            <option value="webp">WebP (.webp)</option>
            <option value="bmp">BMP (.bmp)</option>
          </select>
        </label>
        <div>
          <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
          </div>
          <div class="progress-text" id="progressText"></div>
          <button id="convertBtn">Converti</button>
        </div>
      </div>
    </div>

    <div id="previewContainer" aria-live="polite"></div>
    <div id="resultContainer"></div>
  </main>

  <section class="seo-content">
    <h2>Il Tuo Convertitore di Immagini Online Definitivo</h2>
    <p>Nel mondo digitale di oggi, le immagini sono tutto. Che tu sia un web developer che ottimizza i tempi di caricamento, un social media manager che crea contenuti virali, o un fotografo che archivia i propri scatti, la gestione dei formati di immagine è cruciale. Il nostro strumento gratuito ti offre la flessibilità di convertire le immagini in formati moderni come WebP, standard come JPEG e PNG, e altri ancora, direttamente dal tuo browser, senza installare nulla e nel pieno rispetto della tua privacy.</p>

    <h3>Perché Convertire le Immagini?</h3>
    <p>Ogni formato ha i suoi punti di forza. La conversione ti permette di scegliere il formato giusto per ogni esigenza, bilanciando qualità e peso del file.</p>
    <ul>
      <li>Ottimizzazione per il Web: Converti in WebP per ridurre drasticamente il peso delle immagini senza perdere qualità, migliorando la velocità del tuo sito e la SEO.</li>
      <li>Compatibilità: Assicurati che le tue immagini siano visualizzabili su ogni dispositivo e piattaforma convertendole in formati universalmente supportati come JPEG o PNG.</li>
      <li>Trasparenza e Qualità: Usa il formato PNG quando hai bisogno di sfondi trasparenti o di una compressione senza perdita di dati per loghi e grafiche.</li>
    </ul>

    <h3>Guida ai Formati di Immagine</h3>
    <div class="format-guide">
      <p><strong>WebP</strong>: Un formato moderno di Google che offre compressione superiore (sia con che senza perdita) rispetto a JPEG e PNG. Ideale per il web.</p>
      <p><strong>JPEG</strong>: Il re della fotografia digitale. Offre un'ottima compressione con perdita, ideale per foto complesse con milioni di colori.</p>
      <p><strong>PNG</strong>: Perfetto per grafiche, loghi e immagini che richiedono uno sfondo trasparente. Utilizza una compressione senza perdita di qualità.</p>
      <p><strong>TIFF</strong>: Un formato di alta qualità, spesso non compresso, usato in fotografia professionale e stampa. Non è ideale per il web a causa delle grandi dimensioni dei file.</p>
    </div>

    <h3>Domande Frequenti (FAQ)</h3>
    <div class="faq">
      <div class="faq-item">
        <h4>La conversione delle immagini è sicura?</h4>
        <p>Assolutamente. Tutte le conversioni avvengono localmente nel tuo browser. Nessun file viene caricato sui nostri server, garantendo la massima privacy e sicurezza.</p>
      </div>
      <div class="faq-item">
        <h4>Posso convertire più immagini contemporaneamente?</h4>
        <p>Sì, il nostro strumento è progettato per la conversione multipla. Trascina tutti i file che desideri, seleziona il formato e convertili tutti in una volta.</p>
      </div>
      <div class="faq-item">
        <h4>Perderò qualità durante la conversione?</h4>
        <p>Dipende dai formati. La conversione verso un formato 'lossy' (con perdita) come JPEG implica sempre una minima perdita di qualità per ridurre le dimensioni. La conversione a formati 'lossless' (senza perdita) come PNG preserverà la qualità originale.</p>
      </div>
    </div>
  </section>
</div>

<div id="toastContainer"></div>

<div id="customModal" class="modal-backdrop">
  <div class="modal-dialog">
    <h3 id="modalTitle"></h3>
    <p id="modalMessage"></p>
    <div class="modal-buttons">
      <button id="modalOkBtn">OK</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/utif@4.6.0/UTIF.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const body = document.body;
  const mobileMenu = document.getElementById("mobileMenu");
  const mobileTrigger = document.getElementById("mobile-menu-trigger");
  const mobileClose = document.getElementById("mobile-menu-close");

  mobileTrigger.addEventListener("click", () => {
    mobileMenu.classList.add("active");
    body.classList.add("no-scroll");
  });

  mobileClose.addEventListener("click", () => {
    mobileMenu.classList.remove("active");
    body.classList.remove("no-scroll");
  });

  function applyTheme(theme) {
    document.documentElement.setAttribute("data-theme", theme);
    localStorage.setItem("theme", theme);
    document.getElementById("themeSelector").value = theme;
    document.getElementById("themeSelectorMobile").value = theme;
  }

  document.getElementById("themeSelector").addEventListener("change", (e) => applyTheme(e.target.value));
  document.getElementById("themeSelectorMobile").addEventListener("change", (e) => applyTheme(e.target.value));

  const savedTheme = localStorage.getItem("theme") || "dark";
  applyTheme(savedTheme);

  document.addEventListener("click", (e) => {
    if (mobileMenu.classList.contains("active")) {
      if (e.target === mobileMenu || (!mobileMenu.contains(e.target) && e.target !== mobileTrigger)) {
        mobileMenu.classList.remove("active");
        body.classList.remove("no-scroll");
      }
    }
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && mobileMenu.classList.contains("active")) {
      mobileMenu.classList.remove("active");
      body.classList.remove("no-scroll");
    }
  });

  window.addEventListener("resize", () => {
    if (window.innerWidth > 768 && mobileMenu.classList.contains("active")) {
      mobileMenu.classList.remove("active");
      body.classList.remove("no-scroll");
    }
  });
});

document.addEventListener('DOMContentLoaded', () => {
  const dom = {
    input: document.getElementById('inputFiles'),
    outputFormat: document.getElementById('outputFormat'),
    convertBtn: document.getElementById('convertBtn'),
    dropZone: document.getElementById('dropZone'),
    preview: document.getElementById('previewContainer'),
    result: document.getElementById('resultContainer'),
    progressWrap: document.getElementById('progressContainer'),
    progressBar: document.getElementById('progressBar'),
    progressText: document.getElementById('progressText'),
    modal: document.getElementById('customModal'),
    modalTitle: document.getElementById('modalTitle'),
    modalMessage: document.getElementById('modalMessage'),
    modalOk: document.getElementById('modalOkBtn'),
    toastContainer: document.getElementById('toastContainer')
  };

  const ensureToastContainer = () => {
    if (!dom.toastContainer) {
      const div = document.createElement('div');
      div.id = 'toastContainer';
      document.body.appendChild(div);
      dom.toastContainer = div;
    }
  };

  const showToast = (msg) => {
    ensureToastContainer();
    const t = document.createElement('div');
    t.className = 'toast';
    t.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>${msg}`;
    dom.toastContainer.appendChild(t);
    setTimeout(() => t.remove(), 4000);
  };

  const showModal = (title, message) => {
    if (!dom.modal) return alert(`${title}\n\n${message}`);
    dom.modalTitle.textContent = title;
    dom.modalMessage.textContent = message;
    dom.modal.classList.add('visible');
  };

  const hideModal = () => dom.modal && dom.modal.classList.remove('visible');
  dom.modalOk && dom.modalOk.addEventListener('click', hideModal);
  dom.modal && dom.modal.addEventListener('click', (e) => { if (e.target === dom.modal) hideModal(); });

  const showProgress = (txt = 'Conversione in corso...') => {
    if (dom.progressWrap) dom.progressWrap.style.display = 'block';
    if (dom.progressText) {
      dom.progressText.style.display = 'block';
      dom.progressText.textContent = txt;
    }
    updateProgress(0);
  };

  const hideProgress = () => {
    if (dom.progressWrap) dom.progressWrap.style.display = 'none';
    if (dom.progressText) dom.progressText.style.display = 'none';
  };

  const updateProgress = (p, txt) => {
    if (dom.progressBar) dom.progressBar.style.width = `${Math.max(0, Math.min(100, p))}%`;
    if (txt && dom.progressText) dom.progressText.textContent = txt;
  };

  const isWebPSupported = (() => {
    try {
      const c = document.createElement('canvas');
      return c.toDataURL && c.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    } catch { return false; }
  })();

  const initOutputFormats = () => {
    if (!dom.outputFormat) return;
    const opts = [
      { value: 'png', label: 'PNG (.png)' },
      { value: 'jpeg', label: 'JPEG / JPG (.jpg, .jpeg)' },
      ...(isWebPSupported ? [{ value: 'webp', label: 'WebP (.webp)' }] : []),
      { value: 'bmp', label: 'BMP (.bmp)' }
    ];
    dom.outputFormat.innerHTML = '';
    for (const o of opts) {
      const el = document.createElement('option');
      el.value = o.value;
      el.textContent = o.label;
      dom.outputFormat.appendChild(el);
    }
  };
  initOutputFormats();

  let loadedFiles = [];
  const clearPreviews = () => { if (dom.preview) dom.preview.innerHTML = ''; };

  const testDecodeImage = (file) => new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
    img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Decode fallita')); };
    img.src = url;
  });

  const handleFiles = async (fileList) => {
    loadedFiles = [];
    clearPreviews();
    if (dom.result) dom.result.innerHTML = '';
    hideProgress();

    const files = Array.from(fileList || []).filter(f => f.type.startsWith('image/'));
    if (!files.length) return;

    let idx = 0;
    for (const f of files) {
      try {
        const img = await testDecodeImage(f);
        loadedFiles.push(f);

        if (dom.preview) {
          const thumb = document.createElement('img');
          const reader = new FileReader();
          reader.onload = e => {
            thumb.src = e.target.result;
            thumb.alt = f.name;
            thumb.style.animationDelay = `${idx * 0.06}s`;
            dom.preview.appendChild(thumb);
          };
          reader.readAsDataURL(f);
        }
        idx++;
      } catch {
        showToast(`Input non supportato dal browser: ${f.name}`);
      }
    }
  };

  dom.dropZone && dom.dropZone.addEventListener('click', () => dom.input && dom.input.click());
  dom.input && dom.input.addEventListener('change', (e) => handleFiles(e.target.files));

  if (dom.dropZone) {
    ['dragover', 'dragleave', 'drop'].forEach(ev => {
      dom.dropZone.addEventListener(ev, e => {
        e.preventDefault(); e.stopPropagation();
        if (ev === 'dragover') dom.dropZone.classList.add('drag-glow');
        else dom.dropZone.classList.remove('drag-glow');
        if (ev === 'drop') handleFiles(e.dataTransfer.files);
      });
    });
  }

  const drawOnWhite = (sourceCanvas) => {
    const c = document.createElement('canvas');
    c.width = sourceCanvas.width;
    c.height = sourceCanvas.height;
    const cx = c.getContext('2d');
    cx.fillStyle = '#ffffff';
    cx.fillRect(0, 0, c.width, c.height);
    cx.drawImage(sourceCanvas, 0, 0);
    return c;
  };

  const canvasToBMP24 = (srcCanvas) => {
    const c = drawOnWhite(srcCanvas);
    const w = c.width, h = c.height;
    const ctx = c.getContext('2d');
    const { data } = ctx.getImageData(0, 0, w, h);

    const rowBytes = ((w * 3 + 3) & ~3);
    const imageSize = rowBytes * h;
    const fileSize = 54 + imageSize;
    const buf = new ArrayBuffer(fileSize);
    const dv = new DataView(buf);
    let p = 0;

    dv.setUint8(p++, 0x42);
    dv.setUint8(p++, 0x4D);
    dv.setUint32(p, fileSize, true); p += 4;
    dv.setUint32(p, 0, true); p += 4;
    dv.setUint32(p, 54, true); p += 4;

    dv.setUint32(p, 40, true); p += 4;
    dv.setInt32(p, w, true); p += 4;
    dv.setInt32(p, h, true); p += 4;
    dv.setUint16(p, 1, true); p += 2;
    dv.setUint16(p, 24, true); p += 2;
    dv.setUint32(p, 0, true); p += 4;
    dv.setUint32(p, imageSize, true); p += 4;
    dv.setInt32(p, 2835, true); p += 4;
    dv.setInt32(p, 2835, true); p += 4;
    dv.setUint32(p, 0, true); p += 4;
    dv.setUint32(p, 0, true); p += 4;

    let offset = 54;
    const pad = rowBytes - w * 3;
    for (let y = h - 1; y >= 0; y--) {
      const rowStart = y * w * 4;
      for (let x = 0; x < w; x++) {
        const i = rowStart + x * 4;
        const r = data[i], g = data[i + 1], b = data[i + 2];
        dv.setUint8(offset++, b);
        dv.setUint8(offset++, g);
        dv.setUint8(offset++, r);
      }
      for (let k = 0; k < pad; k++) dv.setUint8(offset++, 0);
    }
    return new Blob([buf], { type: 'image/bmp' });
  };

  const converters = {
    png: async (canvas) => new Promise(res => canvas.toBlob(res, 'image/png')),
    jpeg: async (canvas, quality = 0.92) => new Promise(res => drawOnWhite(canvas).toBlob(res, 'image/jpeg', quality)),
    jpg: async (canvas, quality = 0.92) => converters.jpeg(canvas, quality),
    webp: async (canvas, quality = 0.92) => {
      if (!isWebPSupported) throw new Error('WebP non supportato');
      return new Promise(res => canvas.toBlob(res, 'image/webp', quality));
    },
    bmp: async (canvas) => canvasToBMP24(canvas)
  };

  const extMap = { png: 'png', jpeg: 'jpg', jpg: 'jpg', webp: 'webp', bmp: 'bmp' };

  const processFile = (file, targetFormat) => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const img = new Image();
      img.onload = async () => {
        try {
          const canvas = document.createElement('canvas');
          canvas.width = img.naturalWidth || img.width;
          canvas.height = img.naturalHeight || img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);

          const fn = converters[targetFormat] || converters.png;
          const blob = await fn(canvas);
          const url = URL.createObjectURL(blob);
          const ext = extMap[targetFormat] || 'png';
          const filename = file.name.replace(/\.[^/.]+$/, `.${ext}`);
          resolve({ url, filename });
        } catch (e) {
          reject(e);
        }
      };
      img.onerror = () => reject(new Error('Immagine non decodificabile'));
      img.src = reader.result;
    };
    reader.onerror = () => reject(new Error('Lettura file fallita'));
    reader.readAsDataURL(file);
  });

  dom.convertBtn && dom.convertBtn.addEventListener('click', async () => {
    if (!loadedFiles.length) {
      showModal('Nessun file', 'Seleziona almeno un\'immagine prima di procedere.');
      return;
    }
    const fmt = dom.outputFormat ? dom.outputFormat.value : 'png';

    dom.convertBtn.disabled = true;
    showProgress('Conversione in corso...');
    if (dom.result) dom.result.innerHTML = '';

    const total = loadedFiles.length;
    let done = 0;

    const card = document.createElement('div');
    card.className = 'ios-card';
    card.style.padding = '1rem';
    card.style.textAlign = 'center';
    if (dom.result) dom.result.appendChild(card);

    for (const file of loadedFiles) {
      updateProgress((done / total) * 100, `Elaboro: ${file.name}`);
      try {
        const out = await processFile(file, fmt);
        const item = document.createElement('div');
        item.style.marginBottom = '1rem';
        item.innerHTML = `
          <img src="${out.url}" alt="Anteprima" style="max-width:100%;max-height:200px;border-radius:8px;margin-bottom:.75rem;">
          <br>
          <a href="${out.url}" download="${out.filename}" style="font-weight:600;text-decoration:none;">
            Scarica ${out.filename}
          </a>
        `;
        card.appendChild(item);
      } catch (e) {
        console.error(e);
        showToast(`Impossibile convertire ${file.name} → ${fmt}.`);
      }
      done++;
      updateProgress((done / total) * 100);
    }

    updateProgress(100, 'Fatto!');
    setTimeout(() => { hideProgress(); dom.convertBtn.disabled = false; }, 800);
  });

  const maybePulseBtn = () => {
    if (!dom.convertBtn) return;
    dom.convertBtn.classList.remove('pulsing');
    if (loadedFiles.length) setTimeout(() => dom.convertBtn.classList.add('pulsing'), 350);
  };

  const bindHandleFiles = async (files) => {
    await handleFiles(files);
    maybePulseBtn();
  };

  if (dom.input) dom.input.addEventListener('change', (e) => bindHandleFiles(e.target.files));
  if (dom.dropZone) dom.dropZone.addEventListener('drop', (e) => { e.preventDefault(); bindHandleFiles(e.dataTransfer.files); });

  initOutputFormats();
});
</script>

</body>
</html>
